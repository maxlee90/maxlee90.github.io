---
layout: post
bg: "tools.jpg"
title: "[Effective Java 3rd] 2.객체 파괴"
crawlertitle: "[Effective Java 3rd] || 2.객체 파괴"
summary: "[Effective Java 3rd] || 2.객체 파괴"
date: 2019-02-27
slug: post-url
author: "Max Lee"
permalink: /Posts/
---

### \[Item 7] 다 쓴 객체 참조를 해제하라
자바는 가비지 콜렉터를 갖춘 언어로 메모리 해제에 크게 신경을 쓰지 않아도 되기 때문에 프로그래머로서 마음이 매우 평온해진다. 

**하지만 메모리 관리에 더이상 신경 쓰지 않아도 된다고 오해 할 수 있지만, 절대 절대 아니다!**

메모리 누수는 어디서 일어날까? 간단한 스택을 구현한 객체에서 **주의해야할 부분은 스택이 커졌다가 줄어들었을 때 스택에서 꺼내진 객체들을 가비지 컬렉터가 회수하지 않는다.** 프로그램을 더이상 하용하지 않더라도! **이 스택이 그 객체들의 다 쓴 참조(obsolete reference)를 여전히 가지고 있기 때문이다.**

해결 방법 : 더이상 참조를 하지 않는 \[다 쓴 객체 참조]는 null을 이용해 참조 해제를 한다.

```
public Object pop(){
  if(size ==0) throw new EmptyStact Exception();
  Object result = elements[--size];
  elements[size] = null;          //다 쓴 참조 해제
  return result;
}
```
**하지만 객체 참조를 null 처리하는 일은 예외적인 경우여야 한다.** 자기 메모리를 직접 관리하는 클래스라면 프로그래머는 항시 메모리 누수에 주의해야 한다. 
**캐시 역시 메모리 누수를 일으키는 주범이다!**

메모리 누수의 세번 째 주범은 **리스터(Listener) 혹은 콜백(Callback)** 이라 부르는 것이다. 클라이언트가 콜백을 등록만 하고 명확히 해지하지 않는다, 뭔가 조치해주지 않으면 계속 쌓여갈 것이다. 이러한 경우 **WeakHashMap을 이용해 저장하면 가비지 컬렉터가 즉시 수거해간다.**

메모리 누수는 겉으로 잘 드러나지 않아 시스템에 수년간 잠복하는 사례도 있다. 
