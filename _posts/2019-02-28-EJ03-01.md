---
layout: post
bg: "tools.jpg"
title: "[Effective Java 3rd] 4.클래스와 인터페이스"
crawlertitle: "4.클래스와 인터페이스"
summary: "4.클래스와 인터페이스"
date: 2019-02-28
slug: post-url
author: "Max Lee"
permalink: /Posts/EJ/4
categories: posts
tags: 'Effective-Java'
---

### 핵심 내용
추상화의 기본 단위인 클래스와 인터페이스는 자바 언어의 심장과도 같다. 그래서 자바 언어에는 클래스와 인터페이스 설계에 사용하는 강력한 요소가 많이 있다. 이런 요소를 적절히 활용하여 클래스와 인터페이스를 쓰기 편하고, 견고하며, 유연하게 만드는 방법을 안내한다.

### \[Item 15] 클래스와 멤버의 접근 권한을 최소화하라
**잘 설계된 컴포넌트는 모든 내부 구현을 완벽히 숨겨, 구현과 API를 깔끔히 분리한다.** 오직 API를 통해서만 다른 컴포넌트와 소통하며 서로의 내부 동작 방식에는 전혀 개의치 않는다. 정보 은닉, 혹은 캡슐화라고 하는 이 개념은 소프트웨어 설계의 근간이 되는 원리이다.

정보 은닉의 장점 : 
- 시스템 개발 속도를 높인다. 여러 컴포넌트를 병렬개발 할 수 있기 때문이다.
- 시스템 관리 비용을 낮춘다. 각 컴포넌트를 더 빨리 파악하여 디버깅할 수 있고, 다른 컴포넌트로 교체하는 부담도 적다.
- 정보 은닉 자체가 성능을 높여주지 않지만, 성능 최적화에 도움을 준다. (다른 컴포넌트에 영향주지 않고 해당 컴포넌트만 최적화하면 되기 때문이다)
- 소프트웨어 재사용성을 높인다. 외부에 거의 의존하지 않고 독자적으로 쓰일 수 있다면 낯선 환경에서도 유용하게 쓰일 가능성이 크기 때문이다.
- 큰 시스템을 제작하는 난이도를 낮춘다. 개별 컴포넌트 동작을 검증할 수 있기 때문이다,.

모든 클래스와 멤버의 접근성을 가능한 좁혀야한다. 

톱레벨 클래스와 인터페이스에 부여할 수 있는 접근 수준은 package-private과 public 두가지다. 톱레벨 클래스나 인터페이스를 public으로 선언하면 공개 API가 되며, package-private으로 선언하면 해당 패키지 안에서만 이용할 수 있다.

멤버(필드, 메소드, 중첩 클래스, 중첩 인터페이스)에 부여할 수 있는 접근 범위
- private
- package-private
- protected
- public

클래스의 공개 API를 세심하게 설계한 후, 그 외의 모든 멤버는 private으로 만들자. 그런 다음 오직 같은 패키지의 다른 클래스가 접근 해야하는 멤버에 한하여 package-private으로 풀어주자. 

**단 Serializable을 구현한 클래스에서는 그 필드들도 의도치 않게 공개 API가 될 수도 있다!**

public 클래스의 인스턴스 필드는 되도록 public이 아니어야 한다. public 가변 필드를 갖는 클래스는 일반적으로 스레드에 안전하지 않다.
클래스에서 public static final 배열 필드를 두거나 이 필드를 반환하는 접근자 메서드를 제공해서는 안 된다.

---
### \[Item 16] public 클래스에서는 public 필드가 아닌 접근자 메소드를 사용하라( getter/setter)
### \[Item 17] 변경 가능성을 최소화하라

Getter가 있다고 Setter를 만들지 말아야 한다. 클래스는 꼭 필요한 경우가 아니라면 불변이어야 한다. 장점은 많으나 단점이라고는 특정 상황에서의 잠재적 성능 저하뿐이다. 단순한 값 객체는 항상 불변 객체로 만들자. 

다른 합당한 이유가 없는 모든 필드는 private final으로 선언한다.

생성자는 불변식 설정이 모두 완료된, 초기화가 완벽히 끝난 상태의 객체를 생성해야 한다.

---
### \[Item 18] 상속보다는 컴포지션을 사용하라
상속은 코드를 재사용하는 강력한 수단이지만, 항상 최선은 아니다. 잘못 사용하면 오류를 내기 쉬운 소프트웨어를 만들게 된다. 메소드 호출과 달리 상속은 캡슐화를 깨뜨린다. 상위 클래스 내부 구현이 달라질 경우, 그 여파로 수정도 하지 않은 하위 클래스가 오작동 할 수 있다.

